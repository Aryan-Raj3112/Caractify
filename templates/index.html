{% extends "layout.html" %}

{% block content %}
<body>
    <input type="hidden" id="isLoggedIn" value="{{ 'true' if current_user.is_authenticated else 'false' }}">
    <input type="hidden" id="chatType" value="{{ config.name }}">
    <div class="sidebar">
        <div class="button-group">
            <button class="icon-button" onclick="location.href='/'">
                <span class="tooltip">Home</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
            </button>
            <button class="icon-button" onclick="restartChat()">
                <span class="tooltip">New Chat</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v20M2 12h20"/>
                </svg>
            </button>
        </div>
        <div class="chat-history">
            <h3 class="history-title">Recent Chats</h3>
            {%- if sessions -%}
            <ul class="session-list">
            {%- for session in sessions -%}
            <li class="session-item" data-session-id="{{ session.session_id }}">
                <a href="{{ url_for('load_chat', session_id=session.session_id) }}">
                    <span class="chat-type">{{ session.title }}</span>
                </a>
                <div class="chat-menu">
                    <button class="menu-button" onclick="toggleMenu(this)">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="7" r="1"></circle>
                            <circle cx="12" cy="12" r="1"></circle>
                            <circle cx="12" cy="17" r="1"></circle>
                        </svg>
                    </button>
                    <div class="menu-options">
                        <div class="menu-option" onclick="startRenaming('{{ session.session_id }}', '{{ session.title }}')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                            </svg>
                            Rename
                        </div>
                        <div class="menu-option" onclick="confirmDelete('{{ session.session_id }}')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                            Delete
                        </div>
                    </div>
                </div>
            </li>
            {%- endfor %}
            </ul>
            {%- else -%}
            <p class="no-chats">No previous chats</p>
            {%- endif -%}
        </div>
    </div>
    <button class="menu-toggle" onclick="toggleSidebar()">â˜°</button>
    <div class="main-content">
        <header class="header">
            <img src="{{ url_for('static', filename=config.image) }}" alt="Logo">
            <h2>{{ config.title }}</h2>
        </header>

        <div class="chat-box">
        {%- if chat_history -%}
            {%- for message in chat_history -%}
                <div class="message {{ message['role'] }}-msg"><div class="message-content">
                    {%- for part in message.parts -%}
                        {%- if part.type == "image_ref" -%}
                        <img src="{{ url_for('get_image', image_id=part.image_id) }}" class="chat-image" alt="Uploaded image">
                        {%- else -%}
                        {%- if part.content -%}
                        {{- part.content | markdown | safe if message.role == 'model' else part.content | safe -}}
                        {%- endif -%}
                        {%- endif -%}
                    {%- endfor -%}</div></div>
            {%- endfor -%}
        {%- endif %}
        </div>

        <div id="loading" style="display: none;">
            <div class="bouncing-dots">
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="loading-text">Thinking</div>
        </div>

        <footer class="footer">
            <form action="/stream" method="POST" enctype="multipart/form-data" id="chatForm">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                <input type="hidden" name="chat_type" value="{{ config.name }}">
                <div class="textarea-container">
                    <input type="file" id="imageInput" name="image" accept="image/*" hidden>
                    <button type="button" class="image-upload-button" onclick="document.getElementById('imageInput').click()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                    </button>
                    <textarea autocomplete="off" autofocus name="message" placeholder="Enter your message" required id="messageInput"></textarea>
                    <input type="hidden" name="session_id" value="{{ session_id }}">
                    <button type="submit" class="send-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </form>
            <div class="disclaimer">AI-generated, for reference only</div>
        </footer>
    </div>
    <div class="confirmation-modal" id="deleteModal">
        <div class="modal-content">
            <p>Are you sure you want to delete this chat?</p>
            <div class="modal-buttons">
                <button class="modal-button confirm" onclick="handleDeleteConfirmation(true)">Yes</button>
                <button class="modal-button cancel" onclick="handleDeleteConfirmation(false)">No</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <script>
        marked.setOptions({
            breaks: true,
            mangle: false,
            headerIds: false,
            gfm: true,
            sanitize: false,  // Let DOMPurify handle sanitization
            smartypants: true
        });

        // Helper Functions
        function appendMessage(parts, role) {
            const chatBox = document.querySelector('.chat-box');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${role}-msg`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            // Ensure parts is always an array
            parts = Array.isArray(parts) ? parts : [parts || { type: 'text', content: '' }];
            
            parts.forEach(part => {
                if (part.type === 'text') {
                    messageContent.innerHTML += role === 'model' 
                        ? marked.parse(part.content) 
                        : DOMPurify.sanitize(part.content);
                } else if (part.type === 'image_ref') {
                    const img = document.createElement('img');
                    img.src = `/image/${part.image_id}`;
                    img.className = 'chat-image';
                    messageContent.prepend(img);
                }
            });

            msgDiv.appendChild(messageContent);
            chatBox.appendChild(msgDiv);
            scrollToBottom();
            return msgDiv;
        }

        // Textarea Auto-Grow
        messageInput.addEventListener('input', function() {
            const minHeight = 45;
            this.style.height = `${minHeight}px`;
            const scrollHeight = this.scrollHeight;
            this.style.height = `${Math.max(minHeight, Math.min(scrollHeight, 150))}px`;
        });

        // Enter Key Handler
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                document.getElementById('chatForm').dispatchEvent(new Event('submit'));
            }
        });
        
        window.addEventListener('beforeunload', async () => {
            const csrfToken = document.querySelector('input[name="csrf_token"]').value;
            await fetch('/save_session', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken  // Add CSRF token to headers
                },
                body: JSON.stringify({ session_id: getCookie('session_id') })
            });
        });

        window.addEventListener('beforeunload', async () => {
            const input = document.getElementById('messageInput');
            if (input.value.trim() !== '') {
                await saveSession();
            }
        });

        // Session timeout warning
        let idleTimer;
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
                alert('Your session will expire in 2 minutes due to inactivity');
            }, 28 * 60 * 1000); // 28 minutes
        }

        let chatHistory = [];
        const isLoggedIn = document.getElementById('isLoggedIn').value === 'true';

        if (!isLoggedIn) {
            const savedHistory = sessionStorage.getItem('chatHistory');
            if (savedHistory) {
                chatHistory = JSON.parse(savedHistory);
                // Render existing messages
                chatHistory.forEach(msg => appendMessage(msg.content, msg.role));
            }
        }

        document.addEventListener('mousemove', resetIdleTimer);
        document.addEventListener('keypress', resetIdleTimer);

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
        }

        // Form Handler
        document.getElementById('chatForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            const formData = new FormData(form);
            const csrfToken = document.querySelector('input[name="csrf_token"]').value;

            // Validation checks
            if (!formData.get('message')?.trim() && !imageInput.files[0]) {
                alert('Please enter a message or attach an image');
                return;
            }

            if (!isLoggedIn) {
                const userMessage = formData.get('message').trim();
                const newEntry = {
                    role: 'user',
                    parts: [{ type: 'text', content: userMessage }]
                };
                chatHistory.push(newEntry);
                sessionStorage.setItem('chatHistory', JSON.stringify(chatHistory));
            }

            // Disable input during processing
            messageInput.disabled = true;
            document.getElementById('loading').style.display = 'block';

            try {

                const response = await fetch(form.action, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': csrfToken
                    },
                    credentials: 'include'
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${errorText}`);
                }

                // Clear input and add messages
                const userContent = formData.get('message')?.trim() || '';
                const sessionId = formData.get('session_id');

                // Create user message
                const userMessageDiv = appendMessage([{ type: 'text', content: userContent }], 'user');

                // Handle image if present
                if (imageInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.className = 'chat-image';
                        let messageContent = userMessageDiv.querySelector('.message-content');
                        if (!messageContent) {
                            messageContent = document.createElement('div');
                            messageContent.className = 'message-content';
                            userMessageDiv.appendChild(messageContent);
                        }
                        messageContent.prepend(img);
                    };
                    reader.readAsDataURL(imageInput.files[0]);
                    imageInput.value = '';
                    messageInput.value = '';
                } else {
                    messageInput.value = '';
                }

                let modelMessage = null;
                let fullResponse = '';

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;
                let receivedError = false;

                while (!done) {
                    const { value, done: streamDone } = await reader.read();
                    done = streamDone;

                    if (value) {
                        const chunk = decoder.decode(value);
                        const lines = chunk.trim().split("\n");

                        for (const line of lines) {
                            if (line.startsWith("data: ")) {
                                try {
                                    const jsonStr = line.replace("data: ", "").trim();
                                    const data = JSON.parse(jsonStr);

                                    if (data.chunk) {
                                        if (!modelMessage) {
                                            modelMessage = appendMessage([], 'model');
                                            document.getElementById('loading').style.display = 'none';
                                            messageInput.style.height = '45px';
                                        }
                                        
                                        const cleanedChunk = data.chunk.replace(/\n+$/, '');
                                        fullResponse += cleanedChunk;
                                        
                                        const contentDiv = modelMessage.querySelector('.message-content');
                                        contentDiv.innerHTML = marked.parse(fullResponse);
                                        
                                        setTimeout(() => {
                                            hljs.highlightAll();
                                            scrollToBottom();
                                        }, 50);
                                    }

                                    if (data.error) {
                                        receivedError = true;
                                        throw new Error(data.error);
                                    }
                                    if (!receivedError) {
                                        updateSessionList();
                                        scrollToBottom();
                                    }

                                } catch (err) {
                                    console.error("JSON Parse Error:", err, "Chunk:", line);
                                    appendMessage([{ type: 'text', content: `Error: ${err.message}` }], 'error');
                                }
                            }
                        }
                    }
                }

                updateSessionList();
                document.getElementById('chatType').value = "{{ config.name }}";

            } catch (err) {
                console.error('Stream error:', err);
                appendMessage([{ type: 'text', content: `Error: ${err.message}` }], 'error');
            } finally {
                messageInput.disabled = false;
                imageInput.value = '';
                messageInput.focus();
                updateSessionList();
                document.getElementById('loading').style.display = 'none';
                
                // Use the existing session_id instead of undefined newSessionId
                const sessionId = formData.get('session_id');
                document.cookie = `session_id=${sessionId}; path=/; samesite=strict`;
            }
        });

        async function updateSessionList() {
            const chatType = document.getElementById('chatType').value;
            const sessionList = document.querySelector('.session-list');
            
            if (!sessionList) return; // Exit if no session list element

            try {
                const response = await fetch(`/api/sessions/${chatType}?nocache=${Date.now()}`);
                const sessions = await response.json();
                
                // Only update if we have sessions
                if (sessions.length > 0) {
                    sessionList.innerHTML = sessions.map(session => `
                        <li class="session-item">
                            <a href="/chat/session/${session.session_id}">
                                <span class="chat-type">${session.title}</span>
                            </a>
                        </li>
                    `).join('');
                }
            } catch (err) {
                console.error('Error updating sessions:', err);
            }
        }

        function scrollToBottom() {
            const chatBox = document.querySelector('.chat-box');
            const config = { childList: true, subtree: true }; // Observe changes in child nodes
            const observer = new MutationObserver(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000;
            });
            observer.observe(chatBox, config); // Start observing
            chatBox.scrollTop = chatBox.scrollHeight + 1000; // Initial scroll
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000; // Additional scroll after content loads
            }, 100);
        }

        async function restartChat() {
            const messages = document.querySelectorAll('.message');
            const userMessages = document.querySelectorAll('.user-msg');
            if (userMessages.length === 0) {
                alert('Please start a conversation before creating a new chat.');
                return;
            }

            const isLoggedIn = document.getElementById('isLoggedIn').value === 'true';
            const chatType = document.getElementById('chatType').value;
            const csrfToken = document.querySelector('input[name="csrf_token"]').value;

            try {
                if (isLoggedIn) {
                    // Existing logic for logged-in users
                    const response = await fetch(`/new_chat/${chatType}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        }
                    });
                    const data = await response.json();
                    if (data.status === 'success') {
                        window.location.href = `/chat/session/${data.new_session_id}?nocache=${Date.now()}`;
                    }
                } else {
                    // Force full page reload to clear client-side state
                    sessionStorage.removeItem('chatHistory');
                    const newSessionId = crypto.randomUUID();
                    document.cookie = `session_id=${newSessionId}; path=/; samesite=strict`;
                    window.location.href = `/chat/${chatType}?nocache=${Date.now()}`;
                }
            } catch (err) {
                console.error('Error restarting chat:', err);
            }
        }

        // Update toggleSidebar function
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // Update resize handler
        window.addEventListener('resize', () => {
            const sidebar = document.querySelector('.sidebar');
            if (window.innerWidth > 768) {
                sidebar.classList.remove('collapsed');
            }
        });

        // Update click-outside handler
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768) {
                const sidebar = document.querySelector('.sidebar');
                const menuToggle = document.querySelector('.menu-toggle');
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.add('collapsed');
                }
            }
        });
        let currentSessionToDelete = null;
        let currentSessionToRename = null;

        function toggleMenu(button) {
            const menuOptions = button.parentElement.querySelector('.menu-options');
            const allMenus = document.querySelectorAll('.menu-options');
            
            // Close other open menus
            allMenus.forEach(menu => {
                if (menu !== menuOptions) menu.style.display = 'none';
            });
            
            menuOptions.style.display = menuOptions.style.display === 'block' ? 'none' : 'block';
        }

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.chat-menu')) {
                document.querySelectorAll('.menu-options').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });

        function confirmDelete(sessionId) {
            currentSessionToDelete = sessionId;
            document.getElementById('deleteModal').style.display = 'flex';
        }

        function handleDeleteConfirmation(confirmed) {
            document.getElementById('deleteModal').style.display = 'none';
            if (confirmed && currentSessionToDelete) {
                deleteChatSession(currentSessionToDelete);
            }
            currentSessionToDelete = null;
        }

        async function deleteChatSession(sessionId) {
            try {
                const csrfToken = document.querySelector('input[name="csrf_token"]').value;
                const response = await fetch(`/delete_chat/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                if (response.ok) {
                    const sessionItem = document.querySelector(`.session-item[data-session-id="${sessionId}"]`);
                    if (sessionItem) {
                        sessionItem.remove();
                    }
                    // If deleted session is current session, redirect to home
                    const currentSessionId = getCookie('session_id');
                    if (sessionId === currentSessionId) {
                        window.location.href = '/';
                    }
                } else {
                    alert('Failed to delete chat');
                }
            } catch (error) {
                console.error('Delete error:', error);
                alert('Error deleting chat');
            }
        }

        function startRenaming(sessionId, currentTitle) {
            const sessionItem = document.querySelector(`.session-item[data-session-id="${sessionId}"]`);
            const titleElement = sessionItem.querySelector('.chat-type');
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'rename-input';
            
            titleElement.replaceWith(input);
            input.focus();
            
            input.addEventListener('blur', () => finishRenaming(sessionId, input));
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    finishRenaming(sessionId, input);
                }
            });
        }

        async function finishRenaming(sessionId, input) {
            const newTitle = input.value.trim();
            if (!newTitle) return;

            try {
                const csrfToken = document.querySelector('input[name="csrf_token"]').value;
                const response = await fetch(`/rename_chat/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ new_title: newTitle })
                });

                if (response.ok) {
                    const titleElement = document.createElement('span');
                    titleElement.className = 'chat-type';
                    titleElement.textContent = newTitle;
                    input.replaceWith(titleElement);
                } else {
                    alert('Failed to rename chat');
                }
            } catch (error) {
                console.error('Rename error:', error);
                alert('Error renaming chat');
            }
        }
    </script>
</body>
{% endblock %}