{% extends "layout.html" %}

{% block content %}
<body>
    <div class="sidebar">
        <div class="button-group">
            <button class="icon-button" onclick="location.href='/'">
                <span class="tooltip">Home</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
            </button>
            <button class="icon-button" onclick="restartChat()">
                <span class="tooltip">New Chat</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v20M2 12h20"/>
                </svg>
            </button>
        </div>
        <div class="chat-history">
            <h3 class="history-title">Recent Chats</h3>
            {% if sessions %}
                <ul class="session-list">
                    {% for session in sessions %}
                        <li class="session-item">
                            <a href="{{ url_for('load_chat', session_id=session.session_id) }}">
                                <span class="chat-type">{{ session.title }}</span> <!-- Title here -->
                                <span class="chat-time">{{ session.updated_at | datetimeformat }}</span>
                            </a>
                        </li>
                    {% endfor %}
                </ul>
            {% else %}
                <p class="no-chats">No previous chats</p>
            {% endif %}
        </div>
    </div>

    <div class="main-content">
        <header class="header">
            <img src="{{ url_for('static', filename=config.image) }}" alt="Logo">
            <h2>{{ config.title }}</h2>
        </header>

        <div class="chat-box">
            {% if chat_history %}
                {% for message in chat_history %}
                    <div class="message {{ message['role'] }}-msg">
                        <div class="message-content">
                            {% for part in message.parts %}
                                {% if part.type == "image_ref" %}
                                    <img src="{{ url_for('get_image', image_id=part.image_id) }}" 
                                    class="chat-image" 
                                    alt="Uploaded image">
                                {% else %}
                                    {% if part.content %}
                                        {{ part.content | markdown | safe if message.role == 'model' else part.content | safe }}
                                    {% endif %}
                                {% endif %}
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            {% endif %}
        </div>

        <div id="loading" style="display: none;">
            <div class="bouncing-dots">
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="loading-text">Thinking</div>
        </div>

        <footer class="footer">
            <form action="/stream" method="POST" enctype="multipart/form-data" id="chatForm">
                <div class="textarea-container">
                    <input type="file" id="imageInput" name="image" accept="image/*" hidden>
                    <button type="button" class="image-upload-button" onclick="document.getElementById('imageInput').click()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                    </button>
                    <textarea autocomplete="off" autofocus name="message" placeholder="Enter your message" required id="messageInput"></textarea>
                    <input type="hidden" name="session_id" value="{{ session_id }}">
                    <button type="submit" class="send-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </form>
            <div class="disclaimer">AI-generated, for reference only</div>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <script>
        marked.setOptions({
            breaks: true,
            mangle: false,
            headerIds: false,
            codeSanitizer: true  // Add if needed
        });

        // Helper Functions
        function appendMessage(text, role) {
            const chatBox = document.querySelector('.chat-box');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${role}-msg`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            const sanitized = DOMPurify.sanitize(text);
            messageContent.innerHTML = role === 'model' ? marked.parse(sanitized) : sanitized;
            msgDiv.appendChild(messageContent);

            chatBox.appendChild(msgDiv);
            scrollToBottom();
            return msgDiv;
        }

        function formatDateTime(date) {
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) + 
                ' Â· ' + date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Textarea Auto-Grow
        messageInput.addEventListener('input', function() {
            const minHeight = 45;
            this.style.height = `${minHeight}px`;
            const scrollHeight = this.scrollHeight;
            this.style.height = `${Math.max(minHeight, Math.min(scrollHeight, 150))}px`;
        });

        // Enter Key Handler
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                document.getElementById('chatForm').dispatchEvent(new Event('submit'));
            }
        });

        // Form Handler
        document.getElementById('chatForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const messageInput = document.getElementById('messageInput');
            const imageInput = document.getElementById('imageInput');
            
            // Client-side validation
            if (!formData.get('message')?.trim() && !imageInput.files[0]) {
                alert('Please enter a message or attach an image');
                return;
            }
            // Disable input during processing
            messageInput.disabled = true;
            document.getElementById('loading').style.display = 'block';

            try {
                // Clear input and add messages
                const userContent = formData.get('message')?.trim() || '';
                const sessionId = formData.get('session_id');
                
                // Create user message
                const userMessageDiv = appendMessage(userContent, 'user');
                
                // Handle image if present
                if (imageInput.files[0]) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(imageInput.files[0]);
                    img.className = 'chat-image';
                    img.onload = () => URL.revokeObjectURL(img.src);

                    let messageContent = userMessageDiv.querySelector('.message-content');
                    if (!messageContent) {
                        messageContent = document.createElement('div');
                        messageContent.className = 'message-content';
                        userMessageDiv.appendChild(messageContent);
                    }
                    messageContent.prepend(img);
                    
                    // Clear image input
                    imageInput.value = '';
                    messageInput.value = '';
                }

                let modelMessage = null;
                let fullResponse = ''; // Initialize fullResponse

                const response = await fetch('/stream', { 
                    method: 'POST', 
                    body: formData,
                    credentials: 'same-origin'  // Include cookies
                });

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;
                let receivedError = false; // Flag for error

                while (!done) {
                    const { value, done: streamDone } = await reader.read();
                    done = streamDone;

                    if (value) {
                        const chunk = decoder.decode(value);
                        const lines = chunk.trim().split("\n");

                        for (const line of lines) {
                            if (line.startsWith("data: ")) {
                                try {
                                    const jsonStr = line.replace("data: ", "").trim();
                                    const data = JSON.parse(jsonStr);
                                    

                                    if (data.chunk) {
                                        if (!modelMessage) {
                                            modelMessage = appendMessage('', 'model');
                                            document.getElementById('loading').style.display = 'none';
                                            messageInput.value = '';
                                            messageInput.style.height = '45px'; // Reset height
                                        }
                                        fullResponse += data.chunk; // Simple concatenation
                                        modelMessage.innerHTML = marked.parse(fullResponse);
                                        scrollToBottom();
                                    }

                                    if (data.error) {
                                        receivedError = true;
                                        throw new Error(data.error); // Throw error to be caught
                                    }

                                } catch (err) {
                                    console.error("JSON Parse Error:", err, "Chunk:", line);
                                    appendMessage(`Error: ${err.message}`, 'error'); // Display error in chat
                                }
                            }
                        }
                    }
                }

            } catch (err) {
                console.error('Stream error:', err);
                appendMessage(`Error: ${err.message}`, 'error'); // Display error in chat
            } finally {
                messageInput.disabled = false;
                imageInput.value = ''; // Clear image input
                messageInput.focus();
            }
        });

        function scrollToBottom() {
            const chatBox = document.querySelector('.chat-box');
            const config = { childList: true, subtree: true }; // Observe changes in child nodes
            const observer = new MutationObserver(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000;
            });
            observer.observe(chatBox, config); // Start observing
            chatBox.scrollTop = chatBox.scrollHeight + 1000; // Initial scroll
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000; // Additional scroll after content loads
            }, 100);
        }

        function restartChat() {
            const currentPath = window.location.pathname;
            const chatType = "{{ config.name }}";  // Assuming chat_type is in config
            window.location.href = `/chat/${chatType}`;
        }
    </script>
</body>
{% endblock %}