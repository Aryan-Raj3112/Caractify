{% extends "layout.html" %}

{% block content %}
<body>
    <input type="hidden" id="isLoggedIn" value="{{ 'true' if current_user.is_authenticated else 'false' }}">
    <input type="hidden" id="chatType" value="{{ config.name }}">
    <div class="sidebar">
        <div class="button-group">
            <button class="icon-button" onclick="location.href='/'">
                <span class="tooltip">Home</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
            </button>
            <button class="icon-button" onclick="restartChat()">
                <span class="tooltip">New Chat</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v20M2 12h20"/>
                </svg>
            </button>
        </div>
        <div class="chat-history">
            <h3 class="history-title">Recent Chats</h3>
            {%- if sessions -%}
            <ul class="session-list">
            {%- for session in sessions -%}
            <li class="session-item">
                <a href="{{ url_for('load_chat', session_id=session.session_id) }}">
                    <span class="chat-type">{{ session.title }}</span>
                </a>
            </li>
            {%- endfor %}
            </ul>
            {%- else -%}
            <p class="no-chats">No previous chats</p>
            {%- endif -%}
        </div>
    </div>

    <div class="main-content">
        <header class="header">
            <img src="{{ url_for('static', filename=config.image) }}" alt="Logo">
            <h2>{{ config.title }}</h2>
        </header>

        <div class="chat-box">
        {%- if chat_history -%}
            {%- for message in chat_history -%}
                <div class="message {{ message['role'] }}-msg"><div class="message-content">
                    {%- for part in message.parts -%}
                        {%- if part.type == "image_ref" -%}
                        <img src="{{ url_for('get_image', image_id=part.image_id) }}" class="chat-image" alt="Uploaded image">
                        {%- else -%}
                        {%- if part.content -%}
                        {{- part.content | markdown | safe if message.role == 'model' else part.content | safe -}}
                        {%- endif -%}
                        {%- endif -%}
                    {%- endfor -%}</div></div>
            {%- endfor -%}
        {%- endif %}
        </div>

        <div id="loading" style="display: none;">
            <div class="bouncing-dots">
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="loading-text">Thinking</div>
        </div>

        <footer class="footer">
            <form action="/stream" method="POST" enctype="multipart/form-data" id="chatForm">
                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                <input type="hidden" name="chat_type" value="{{ config.name }}">
                <div class="textarea-container">
                    <input type="file" id="imageInput" name="image" accept="image/*" hidden>
                    <button type="button" class="image-upload-button" onclick="document.getElementById('imageInput').click()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                    </button>
                    <textarea autocomplete="off" autofocus name="message" placeholder="Enter your message" required id="messageInput"></textarea>
                    <input type="hidden" name="session_id" value="{{ session_id }}">
                    <button type="submit" class="send-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </form>
            <div class="disclaimer">AI-generated, for reference only</div>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    
    <script>
        marked.setOptions({
            breaks: true,
            mangle: false,
            headerIds: false,
            gfm: true,
            sanitize: false,  // Let DOMPurify handle sanitization
            smartypants: true
        });

        // Helper Functions
        function appendMessage(parts, role) {
            const chatBox = document.querySelector('.chat-box');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${role}-msg`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            parts.forEach(part => {
                if (part.type === 'text') {
                    messageContent.innerHTML += role === 'model' 
                        ? marked.parse(part.content) 
                        : DOMPurify.sanitize(part.content);
                } else if (part.type === 'image_ref') {
                    const img = document.createElement('img');
                    img.src = `/image/${part.image_id}`;
                    img.className = 'chat-image';
                    messageContent.prepend(img);
                }
            });


            msgDiv.appendChild(messageContent);

            chatBox.appendChild(msgDiv);
            scrollToBottom();
            return msgDiv;
        }

        // Textarea Auto-Grow
        messageInput.addEventListener('input', function() {
            const minHeight = 45;
            this.style.height = `${minHeight}px`;
            const scrollHeight = this.scrollHeight;
            this.style.height = `${Math.max(minHeight, Math.min(scrollHeight, 150))}px`;
        });

        // Enter Key Handler
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                document.getElementById('chatForm').dispatchEvent(new Event('submit'));
            }
        });
        
        window.addEventListener('beforeunload', async () => {
            const csrfToken = document.querySelector('input[name="csrf_token"]').value;
            await fetch('/save_session', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken  // Add CSRF token to headers
                },
                body: JSON.stringify({ session_id: getCookie('session_id') })
            });
        });

        window.addEventListener('beforeunload', async () => {
            const input = document.getElementById('messageInput');
            if (input.value.trim() !== '') {
                await saveSession();
            }
        });

        // Session timeout warning
        let idleTimer;
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
                alert('Your session will expire in 2 minutes due to inactivity');
            }, 28 * 60 * 1000); // 28 minutes
        }

        let chatHistory = [];
        const isLoggedIn = document.getElementById('isLoggedIn').value === 'true';

        if (!isLoggedIn) {
            const savedHistory = sessionStorage.getItem('chatHistory');
            if (savedHistory) {
                chatHistory = JSON.parse(savedHistory);
                // Render existing messages
                chatHistory.forEach(msg => appendMessage(msg.content, msg.role));
            }
        }

        document.addEventListener('mousemove', resetIdleTimer);
        document.addEventListener('keypress', resetIdleTimer);

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
        }

        // Form Handler
        document.getElementById('chatForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const sessionId = formData.get('session_id');

            if (!formData.get('message')?.trim() && !imageInput.files[0]) {
                alert('Please enter a message or attach an image');
                return;
            }

            if (!isLoggedIn) {
                const userMessage = formData.get('message').trim();
                const newEntry = {
                    role: 'user',
                    parts: [{ type: 'text', content: userMessage }]
                };
                chatHistory.push(newEntry);
                sessionStorage.setItem('chatHistory', JSON.stringify(chatHistory));
            }
            
            // Client-side validation
            if (!formData.get('message')?.trim() && !imageInput.files[0]) {
                alert('Please enter a message or attach an image');
                return;
            }
            // Disable input during processing
            messageInput.disabled = true;
            document.getElementById('loading').style.display = 'block';

            try {
                // Clear input and add messages
                const userContent = formData.get('message')?.trim() || '';
                const sessionId = formData.get('session_id');
                
                // Create user message
                const userMessageDiv = appendMessage([{ type: 'text', content: userContent }], 'user'); // Modified to use parts
                
                // Handle image if present
                if (imageInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.className = 'chat-image';
                        let messageContent = userMessageDiv.querySelector('.message-content');
                        if (!messageContent) {
                            messageContent = document.createElement('div');
                            messageContent.className = 'message-content';
                            userMessageDiv.appendChild(messageContent);
                        }
                        messageContent.prepend(img);
                    };
                    reader.readAsDataURL(imageInput.files[0]);

                    // Clear image input
                    imageInput.value = '';
                    messageInput.value = '';
                } else {
                    messageInput.value = '';
                }

                let modelMessage = null;
                let fullResponse = '';

                const response = await fetch('/stream', { 
                    method: 'POST', 
                    body: formData,
                    credentials: 'include' // Add this to send cookies
                });

                if (!response.ok) {
                    throw new Error(await response.text());
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;
                let receivedError = false; // Flag for error

                while (!done) {
                    const { value, done: streamDone } = await reader.read();
                    done = streamDone;

                    if (value) {
                        const chunk = decoder.decode(value);
                        const lines = chunk.trim().split("\n");

                        for (const line of lines) {
                            if (line.startsWith("data: ")) {
                                try {
                                    const jsonStr = line.replace("data: ", "").trim();
                                    const data = JSON.parse(jsonStr);
                                    

                                    if (data.chunk) {
                                        if (!modelMessage) {
                                            modelMessage = appendMessage([], 'model');
                                            document.getElementById('loading').style.display = 'none';
                                            messageInput.value = '';
                                            messageInput.style.height = '45px';
                                        }
                                        
                                        // Trim trailing newlines and whitespace
                                        const cleanedChunk = data.chunk.replace(/\n+$/, '');
                                        fullResponse += cleanedChunk;
                                        
                                        const contentDiv = modelMessage.querySelector('.message-content');
                                        contentDiv.innerHTML = marked.parse(fullResponse);
                                        
                                        // Add slight delay for rendering
                                        setTimeout(() => {
                                            hljs.highlightAll();
                                            scrollToBottom();
                                        }, 50);
                                    }

                                    if (data.error) {
                                        receivedError = true;
                                        throw new Error(data.error); // Throw error to be caught
                                    }

                                } catch (err) {
                                    console.error("JSON Parse Error:", err, "Chunk:", line);
                                    appendMessage(`Error: ${err.message}`, 'error'); // Display error in chat
                                }
                            }
                        }
                    }
                }

                updateSessionList();
                document.getElementById('chatType').value = "{{ config.name }}";

            } catch (err) {
                console.error('Stream error:', err);
                appendMessage(`Error: ${err.message}`, 'error'); // Display error in chat
            } finally {
                messageInput.disabled = false;
                imageInput.value = '';
                messageInput.focus();
                updateSessionList(); // Add this line
                document.getElementById('loading').style.display = 'none';
                document.cookie = `session_id=${newSessionId}; path=/; samesite=strict`;
            }
        });

        async function updateSessionList() {
            const chatType = document.getElementById('chatType').value;
            try {
                const response = await fetch(`/api/sessions/${chatType}?nocache=${Date.now()}`);
                const sessions = await response.json();
                
                const sessionList = document.querySelector('.session-list');
                sessionList.innerHTML = sessions.map(session => `
                    <li class="session-item">
                        <a href="/chat/session/${session.session_id}">
                            <span class="chat-type">${session.title}</span>
                        </a>
                    </li>
                `).join('');
            } catch (err) {
                console.error('Error updating sessions:', err);
            }
        }

        function scrollToBottom() {
            const chatBox = document.querySelector('.chat-box');
            const config = { childList: true, subtree: true }; // Observe changes in child nodes
            const observer = new MutationObserver(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000;
            });
            observer.observe(chatBox, config); // Start observing
            chatBox.scrollTop = chatBox.scrollHeight + 1000; // Initial scroll
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight + 1000; // Additional scroll after content loads
            }, 100);
        }

        function restartChat() {
            const isLoggedIn = document.getElementById('isLoggedIn').value === 'true';
            
            if (!isLoggedIn) {
                // Clear session cookie for anonymous users
                document.cookie = 'session_id=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            }
            
            // Generate new session ID
            const newSessionId = crypto.randomUUID();
            
            // Set new session cookie with proper attributes
            document.cookie = `session_id=${newSessionId}; path=/; samesite=strict`;
            
            // Redirect to new session
            window.location.href = `/chat/${document.getElementById('chatType').value}`;
        }
    </script>
</body>
{% endblock %}